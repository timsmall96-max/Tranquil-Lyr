<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tranquil Lyrics</title>
  <style>
  :root {
  --overlay: rgba(0, 0, 0, 0.45);
  --editor-bg: rgba(20, 20, 25, 0.65);
  --text-color: #f2f6ff;
  --gutter-bg: rgba(0, 0, 0, 0.35);
  --gutter-text: #9fd3ff;
  --font: "Georgia", serif;
  --font-size: 17px;
}

 html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  font-family: var(--font);
  height: 100%;
}

    body {
  background-image: url("https://raw.githubusercontent.com/timsmall96-max/Image/main/BG.jpg");
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  overflow-x: hidden; /* ‚úÖ correct placement */
}

.overlay {
  position: fixed;
  inset: 0;
  height: 100vh;          /* ‚¨ÖÔ∏è THIS is the key addition */
  background: var(--overlay);
  display: flex;
  justify-content: center;
  align-items: stretch;
  overflow: hidden;
}

.editor-wrapper {
  width: 90%;
  max-width: 1000px;
  margin: 20px;
  background: var(--editor-bg);
  border-radius: 10px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  flex: 1;
  min-height: 0;
  height: calc(100% - 40px); /* ‚¨ÖÔ∏è key fix */
}

    


    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 10px;
      background: rgba(0,0,0,0.4);
    }

    .toolbar button, .toolbar input {
      background: rgba(255,255,255,0.15);
      color: white;
      border: none;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
    }

    .toolbar button:hover {
      background: rgba(255,255,255,0.3);
    }

   .editor-area {
  display: flex;
  flex: 1;
  min-height: 0;
  overflow: hidden;
}

    .gutter {
      background: transparent;
      color: var(--text-color);
      padding: 10px;
      text-align: right;
      min-width: 60px;
      line-height: 1.4;
      white-space: pre;
      user-select: none;
      overflow: hidden;
      font-size: var(--font-size);
      font-family: var(--font);
    }

    #editor {
      flex: 1;
      padding: 10px;
      background: transparent;
      color: var(--text-color);
      font-size: var(--font-size);
      line-height: 1.4;
      outline: none;
      overflow: auto;
      white-space: pre-wrap;
    }

   .reference-panel {
  background: rgba(0, 0, 0, 0.35);
  display: flex;
  flex-direction: column;

  /* ‚úÖ SAFE sizing inside flex */
  flex: 0 0 auto;
  min-height: 160px;
}

    .reference-panel:fullscreen {
      height: 100%;
      border-radius: 0;
    }

    .reference-tabs {
      display: flex;
      gap: 8px;
      padding: 8px;
    }

    .tab {
      background: rgba(255,255,255,0.15);
      border: none;
      color: white;
      padding: 6px 10px;
      border-radius: 999px;
      cursor: pointer;
    }

    .tab.active {
      background: rgba(255,255,255,0.35);
    }

    .reference-hint {
      display: none;
      padding: 6px 10px;
      font-size: 12px;
      color: #ddd;
    }

    .reference-frame {
      flex: 1;
      border: none;
    }
.layout-container {
  display: flex;
  width: 100%;
  height: 100%;
  min-height: 0; /* critical for nested flex scrolling */
  align-items: stretch;
}
.metronome-panel {
  position: relative; /* ‚úÖ REQUIRED */
  padding-bottom: 60px; /* ‚úÖ ADD THIS */
  width: 90px; /* üëà sweet spot */
  background: rgba(0, 0, 0, 0.4);
  color: white;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 10px 5px;
  gap: 10px;
  font-size: 14px;
  overflow-y: auto;
}

.metronome-panel input {
  width: 40px;
  text-align: center;
  background: rgba(255, 255, 255, 0.15);
  color: white;
  border: none;
  border-radius: 4px;
  padding: 4px;
}

.metronome-panel button {
  background: rgba(255, 255, 255, 0.15);
  color: white;
  border: none;
  border-radius: 4px;
  padding: 4px 6px;
  cursor: pointer;
}

.metronome-panel button:hover {
  background: rgba(255, 255, 255, 0.3);
}
.metronome-light {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background-color: #222;
  border: 2px solid #555;
  box-shadow: 0 0 4px #000;
  transition: background-color 0.1s ease, box-shadow 0.1s ease;
}
.metronome-light.on {
  background-color: #3fa;
  box-shadow: 0 0 8px #3fa;
}
.metronome-light.first {
  background-color: #f44;
  box-shadow: 0 0 10px #f44;
}
.slider-label {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}

.slider-label span {
  font-size: 11px;
  opacity: 0.85;
}

.metronome-panel input[type="range"] {
  width: 100%;
}
#radio-controls {
  display: flex;
  gap: 6px;
  margin-top: 12px;
}

#radio-controls button {
  background: rgba(255,255,255,0.1);
  border: none;
  color: #fff;
  font-size: 14px;
  padding: 6px;
  border-radius: 4px;
  cursor: pointer;
}

#radio-controls button:hover {
  background: rgba(255,255,255,0.25);
}

    
/* ===============================
   REPETITION BUTTON POLISH
   =============================== */

#repToggle {
  transition: opacity 0.2s ease, background 0.2s ease;
}

#repToggle.active {
  background: rgba(255, 100, 100, 0.35);
}
/* ===============================
   SIMPLE BEAT PULSE (SAFE)
   =============================== */

#editor.beat-pulse {
  animation: beatPulse 0.12s ease-out;
}

#editor.beat-pulse.first {
  animation: beatPulseFirst 0.12s ease-out;
}

@keyframes beatPulse {
  0%   { box-shadow: 0 0 0 rgba(255,255,255,0); }
  60%  { box-shadow: 0 0 14px rgba(255,255,255,0.25); }
  100% { box-shadow: 0 0 0 rgba(255,255,255,0); }
}

@keyframes beatPulseFirst {
  0%   { box-shadow: 0 0 0 rgba(255,255,255,0); }
  60%  { box-shadow: 0 0 18px rgba(255,120,120,0.35); }
  100% { box-shadow: 0 0 0 rgba(255,255,255,0); }
}

/* ===============================
   PERFORMANCE MODE
   =============================== */

body.performance-mode .toolbar,
body.performance-mode .reference-panel {
  display: none;
}

body.performance-mode .editor-wrapper {
  max-width: none;
  width: 100%;
  margin: 0;
  border-radius: 0;
}

body.performance-mode #editor {
  font-size: calc(var(--font-size) * 1.6);
  line-height: 1.6;
}

body.performance-mode .gutter {
  font-size: calc(var(--font-size) * 1.6);
  opacity: 0.7;
}

body.performance-mode {
  background-color: #000;
}

body.performance-mode .overlay {
  background: rgba(0, 0, 0, 0.75);
}

/* Hide syllable gutter in Performance Mode */
body.performance-mode .gutter {
  display: none;
}


#aiDrawer {
  position: fixed;
  right: 0;
  top: 0;
  width: min(100vw, 360px);
  height: 100dvh;               /* ‚Üê critical for mobile */
  background: rgba(12,12,18,0.98);
  color: white;
  display: flex;
  flex-direction: column;
  z-index: 99999;
  border-left: 1px solid rgba(255,255,255,0.1);
}
.ai-input {
  flex-shrink: 0;
  padding: 10px;
  background: rgba(12,12,18,0.98);
  border-top: 1px solid rgba(255,255,255,0.1);
}

.ai-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  background: rgba(255,255,255,0.06);
  font-size: 14px;
}

#aiMessages {
  flex: 1;
  overflow-y: auto;
  padding: 10px;
  min-height: 0;   /* ‚Üê CRITICAL for flex scrolling */
}

#aiMessages div {
  margin-bottom: 8px;
}

.ai-input {
  display: flex;
  gap: 6px;
  padding: 10px;
}

.ai-input input {
  flex: 1;
  background: rgba(255,255,255,0.1);
  border: none;
  color: white;
  padding: 6px;
  border-radius: 4px;
}

@media (max-width: 768px) {
  body {
    overflow: hidden;
  }

  .layout-container {
    flex-direction: column;
  }

  .metronome-panel {
    position: fixed;
    left: 0;
    bottom: 0;
    width: 100%;
    height: 0;
    overflow: hidden;
    background: rgba(0,0,0,0.92);
    z-index: 9999;
    transition: height 0.3s ease;

    border-top-left-radius: 14px;
    border-top-right-radius: 14px;
    box-shadow: 0 -10px 30px rgba(0,0,0,0.6);
  }

  .metronome-panel.open {
    height: 55vh;
    overflow-y: auto;
  }

  .editor-wrapper {
    width: 100%;
    max-width: none;
    margin: 0;
    border-radius: 0;
    height: 100%;
  }

  .toolbar {
    overflow-x: auto;
    white-space: nowrap;
  }

  .toolbar button,
  .toolbar label {
    flex: 0 0 auto;
  }

  .reference-panel {
    max-height: 35vh;
  }
}

    @media (max-width: 768px) {
  .reference-panel {
    flex: none;
    height: 35vh;
    min-height: 0;
  }

  .reference-frame {
    height: 100%;
  }
}




/* ===============================
   MOBILE FLOATING BUTTONS (CLEAN)
   =============================== */

/* Desktop: never show */
.mobile-fab {
  display: none;
}

/* Mobile only */
@media (max-width: 768px) {

  .mobile-fab {
    display: inline-flex;
    align-items: center;
    justify-content: center;

    position: fixed;
    right: 16px;

    padding: 12px 18px;
    border-radius: 999px;

    background: rgba(0, 0, 0, 0.85);
    color: white;
    border: none;

    font-size: 14px;
    font-weight: 600;
    white-space: nowrap;

    box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    cursor: pointer;
    z-index: 10000;
  }

  #mobileControls {
    bottom: 16px;
  }

  #mobileToolbar {
    bottom: 68px;
  }

  .mobile-fab:active {
    transform: scale(0.96);
  }

  /* Toolbar toggle (Tools button) */
  .toolbar {
    display: none;
  }

  .toolbar.open {
    display: flex;
  }
}


@media (max-width: 768px) {

  /* Controls drawer content = vertical list */
  .metronome-panel {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 14px;
  }

  /* Any inner groups stack vertically */
  .metronome-panel > div,
  .metronome-panel label {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 6px;
  }

  /* Inputs & buttons fill width */
  .metronome-panel input,
  .metronome-panel select,
  .metronome-panel button {
    width: 100%;
  }

  /* Range sliders look correct */
  .metronome-panel input[type="range"] {
    width: 100%;
  }

  /* Small text stays readable */
  .metronome-panel span,
  .metronome-panel label {
    font-size: 13px;
  }
}


  </style>
</head>

<body>
<div class="overlay">
  <div class="layout-container">
 <!-- LEFT COLUMN: Metronome Panel -->
   

   
<div class="metronome-panel">
  <div id="metronomeLight" class="metronome-light"></div>

  <label for="timeSignature" style="font-size: 12px;">TS</label>
  <select id="timeSignature" style="width: 50px;">
    <option value="4">4/4</option>
    <option value="3">3/4</option>
    <option value="5">5/4</option>
    <option value="6">6/8</option>
    <option value="7">7/8</option>
  </select>

  <button id="metronomeToggle">Start</button>
  <input id="bpmInput" type="number" min="30" max="300" value="100" />

  <label style="font-size: 12px;">Rhythm</label>
  <div id="rhythmLight" style="
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background-color: #444;
    border: 2px solid #555;
    box-shadow: 0 0 4px #000;
    transition: background-color 0.2s ease, box-shadow 0.2s ease;">
  </div>
<div style="display:flex; gap:10px; flex-wrap:wrap; font-size:12px;">
  <label>
    <span>Padding</span>
    <input type="range" id="padSlider" min="0.3" max="0.8" step="0.01" value="0.45">
  </label>

  <label>
    <span>Density</span>
    <input type="range" id="densitySlider" min="0.2" max="0.6" step="0.01" value="0.38">
  </label>

<label>
  <span>Stress</span>
  <input
    type="range"
    id="stressSlider"
    min="0.3"
    max="0.8"
    step="0.05"
    value="0.6"
  >




</label>


  <label>
    <span>Variance</span>
    <input type="range" id="varianceSlider" min="1" max="5" step="0.1" value="2.8">
  </label>
  <button id="repToggle">Repetition</button>
  <button id="performanceToggle">Performance</button>
</div>

<div id="rhythmDebug" style="
  font-size: 11px;
  line-height: 1.3;
  text-align: center;
  color: #ddd;
  min-height: 32px;
  opacity: 0.85;
">


</div>



<button id="aiToggle">AI</button>

  <button id="rhymeToggle">Show Rhyme</button>


<button id="connectDropbox">
  Connect Dropbox
</button>



<button id="saveToDropbox">
  Save to Dropbox
</button>

<button id="loadFromDropbox">
  Load from Dropbox
</button>


<div id="radio-controls">
  <button id="prev-radio">‚èÆ</button>
  <button id="toggle-radio">‚ñ∂</button>
  <button id="next-radio">‚è≠</button>
</div>

<audio id="radio-player" preload="none"></audio>
</div>


  <!-- RIGHT: Existing Editor -->
    <div class="editor-wrapper">
        
      <!-- your editor, toolbar, etc. stays the same -->
    <input
  id="songTitle"
  type="text"
  placeholder="Song Title"
  style="
    background: transparent;
    color: var(--text-color);
    border: none;
    border-bottom: 1px solid rgba(255,255,255,0.3);
    padding: 10px;
    font-size: 22px;
    font-weight: bold;
    outline: none;
  "
/>

    <!-- Toolbar -->
    <div class="toolbar">
      <button id="newBtn">Start New</button>
      <button id="openBtn">Open</button>
      <button id="saveBtn">Save</button>
      <button id="saveAsBtn">Save As</button>
      <button id="refFullscreenBtn">Reference Fullscreen</button>
      <button id="fontDown">A‚àí</button>
      <button id="fontUp">A+</button>
      <label>Text <input type="color" id="textColor"></label>
      <label>Highlight <input type="color" id="highlightColor" value="#ffff00"></label>
      <button id="highlightBtn">Highlight</button>
      <button id="emailBtn">Send Email</button>
      <label>
        üìê Ref Height
        <input type="range" id="refSizeSlider" min="100" max="600" value="260" style="width: 100px;">
      </label>
    </div>
    
    <!-- Repetition Alert -->
<div id="repetitionAlert" style="
  display:none;
  background: rgba(255,80,80,0.15);
  color: #ffdede;
  font-size: 13px;
  padding: 6px 10px;
  border-top: 1px solid rgba(255,80,80,0.3);
  border-bottom: 1px solid rgba(255,80,80,0.3);
">
</div>
    <!-- Editor Area -->
    <div class="editor-area">
      <div id="gutter" class="gutter"></div>
      <div id="editor" contenteditable="true"></div>
    </div>

    
<!-- Reference Panel -->
<div class="reference-panel">
  <div class="reference-tabs">
    <button class="tab active" data-site="rhyme">Rhyme</button>
    <button class="tab" data-site="exercises">Exercises</button>
    <button class="tab" data-site="wiki">Wiki</button>
  </div>

  <div id="referenceHint" class="reference-hint"></div>

  <iframe
    id="referenceFrame"
    class="reference-frame"
    src="https://www.rhymezone.com/"
  ></iframe>
</div>


  </div>
</div>

<script>
const editor = document.getElementById("editor");
const gutter = document.getElementById("gutter");
const frame = document.getElementById("referenceFrame");
const hint = document.getElementById("referenceHint");
const root = document.documentElement.style;
const rhythmLight = document.getElementById("rhythmLight");
const rhythmDebug = document.getElementById("rhythmDebug");
const stations = [
  {
    name: "Jazz (Working)",
    url: "PASTE_YOUR_CURRENT_JAZZ_STREAM_HERE"
  },

  {
    name: "Lo-Fi / Chillhop",
    url: "https://stream.nightride.fm/chillhop.mp3"
  },

  {
    name: "Ambient",
    url: "https://icecast.radiofrance.fr/fip-midfi.mp3"
  },

  {
    name: "Classical",
    url: "https://icecast.radiofrance.fr/francemusique-midfi.mp3"
  },

  {
    name: "Groove / Soul",
    url: "https://icecast.radiofrance.fr/fipgroove-midfi.mp3"
  }
];
const DROPBOX_APP_KEY = "aqspa246xk6m1mt";
const DROPBOX_TOKEN_KEY = "dropbox_access_token";

function getDropboxToken() {
  return localStorage.getItem(DROPBOX_TOKEN_KEY);
}


const RHYME_COLORS = [
  "#ff6b6b", // red
  "#feca57", // yellow
  "#48dbfb", // blue
  "#1dd1a1", // green
  "#5f27cd", // purple
  "#ff9ff3", // pink
  "#54a0ff", // sky
  "#00d2d3"  // teal
];
 



  let rhymeEnabled = false;

  function getRhymeKey(word) {
  const clean = word.toLowerCase().replace(/[^a-z']/g, "");
  if (!clean) return null;

  // Use CMU dictionary if possible
  if (CMU_DICT && CMU_DICT[clean]) {
    const phones = CMU_DICT[clean][0];

    // Take from last stressed vowel onward
    for (let i = phones.length - 1; i >= 0; i--) {
      if (/\d$/.test(phones[i])) {
        return phones.slice(i).join("-");
      }
    }
  }

  // Fallback: crude spelling-based rhyme
  if (clean.length > 3) return clean.slice(-3);
  return null;
}

  function getAllRhymes(lines) {
  const map = {};

  lines.forEach((line, lineIndex) => {
    const words = line.split(/\s+/);

    words.forEach((word, wordIndex) => {
      const key = getRhymeKey(word);
      if (!key) return;

      if (!map[key]) map[key] = [];
      map[key].push({ lineIndex, wordIndex, word });
    });
  });

  return map;
}
function isCaretInsideEditor() {
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return false;

  const range = sel.getRangeAt(0);
  return editor.contains(range.commonAncestorContainer);
}

  
  function applyRhymeColors() {
  if (!CMU_DICT) return; // ‚¨ÖÔ∏è guard stays

  const lines = editor.innerText.split("\n");
  const rhymeMap = getAllRhymes(lines);

  let colorIndex = 0;
  const rhymeColors = {};

  // Assign colors only to real rhymes
  Object.entries(rhymeMap).forEach(([key, occ]) => {
    if (occ.length >= 2) {
      rhymeColors[key] = RHYME_COLORS[colorIndex % RHYME_COLORS.length];
      colorIndex++;
    }
  });

  

  const newHTML = lines.map(line => {
    let words = line.split(/\s+/);

    words = words.map(word => {
      const key = getRhymeKey(word);
      if (!key || !rhymeColors[key]) return word;

      const cleanWord = word.toLowerCase().replace(/[^a-z']/g, "");
      const isEndWord = getLastWord(line) === cleanWord;

      return `<span class="rhyme-highlight"
        style="
          color:${rhymeColors[key]};
          ${isEndWord
            ? "font-weight:600;"
            : "opacity:0.7;text-decoration:underline;"}
        ">${word}</span>`;
    });

    return words.join(" ");
  }).join("<br>");

  editor.innerHTML = newHTML;
}




let rhymeTimer = null;

  function removeRhymeColors() {
  const spans = editor.querySelectorAll(".rhyme-highlight");

  spans.forEach(span => {
    const parent = span.parentNode;
    while (span.firstChild) {
      parent.insertBefore(span.firstChild, span);
    }
    parent.removeChild(span);
    parent.normalize();
  });
}


  
function scheduleRhymeUpdate() {
  if (!rhymeEnabled) return;

  clearTimeout(rhymeTimer);

  rhymeTimer = setTimeout(() => {
    if (isCaretInsideEditor()) return;
    applyRhymeColors();
  }, 600);
}


editor.addEventListener("input", scheduleRhymeUpdate);
 



/* ===============================
   LOAD CMU DICTIONARY (Netlify-safe)
   =============================== */

let CMU_DICT = null;


window.addEventListener("DOMContentLoaded", () => {
  fetch("/cmudict.json")
    .then(res => {
      if (!res.ok) {
        throw new Error(`Failed to load cumudict.json (${res.status})`);
      }
      return res.json();
    })
    .then(data => {
      CMU_DICT = data;
      console.log("CMU Dictionary loaded:", Object.keys(data).length);
      updateGutter(); // ‚Üê this is the important line
    })
    .catch(err => {
      console.error("CMU Dictionary load error:", err);
    });
});

const LYRICS_KEY = "tranquilLyrics_autosave";
const TITLE_KEY = "tranquilLyrics_title";

const titleInput = document.getElementById("songTitle");
const savedTitle = localStorage.getItem(TITLE_KEY);
if (savedTitle) titleInput.value = savedTitle;

// === Tunable thresholds ===
let PAD_THRESHOLD = 0.45;
let DENSITY_THRESHOLD = 0.38;
let VARIANCE_THRESHOLD = 2.8;
let STRESS_STRICTNESS = 0.6; // ‚Üê controlled by slider

// === Sliders ===
const padSlider = document.getElementById("padSlider");
padSlider.oninput = e => {
  PAD_THRESHOLD = +e.target.value;
};

const densitySlider = document.getElementById("densitySlider");
densitySlider.oninput = e => {
  DENSITY_THRESHOLD = +e.target.value;
};

const varianceSlider = document.getElementById("varianceSlider");
varianceSlider.oninput = e => {
  VARIANCE_THRESHOLD = +e.target.value;
};

const stressSlider = document.getElementById("stressSlider");
stressSlider.oninput = e => {
  // Inverted so LEFT = stricter, RIGHT = looser
  STRESS_STRICTNESS = 1 - +e.target.value;
};





function makeSafeFilename(name) {
  return name
    .trim()
    .replace(/[<>:"/\\|?*\x00-\x1F]/g, "")
    .replace(/\s+/g, " ")
    .slice(0, 100) || "lyrics";
}


/* === Load Saved Settings === */
const save = (k, v) => localStorage.setItem(k, v);
const load = k => localStorage.getItem(k);

function loadSettings() {
  const fontSize = load("fontSize");
  const textColor = load("textColor");

  if (fontSize) root.setProperty("--font-size", fontSize);
  if (textColor) {
    root.setProperty("--text-color", textColor);
    document.getElementById("textColor").value = textColor;
  }
}
loadSettings();

/* === Syllable Count === */
function countSyllables(word) {
  if (!word) return 0;

  const clean = word.toLowerCase().replace(/[^a-z']/g, "");

  // ‚úÖ Use CMU dictionary if loaded
  if (CMU_DICT && CMU_DICT[clean]) {
    // CMU format: array of phoneme arrays
    // Count vowel phonemes (they end in a digit)
    const pronunciation = CMU_DICT[clean][0];
    return pronunciation.filter(p => /\d$/.test(p)).length;
  }

  // üîÅ Fallback heuristic (your original logic)
  if (clean.length <= 3) return clean ? 1 : 0;
  const w = clean.replace(/e$/, "");
  const g = w.match(/[aeiouy]+/g);
  return g ? g.length : 1;
}
function getLastWord(line) {
  const words = line.trim().split(/\s+/);
  return words.length ? words[words.length - 1].toLowerCase() : "";
}

/* ===============================
   STRESS + PADDING HELPERS
   =============================== */

const FILLER_WORDS = new Set([
  "the","a","an","to","of","and","but","or","so",
  "that","this","it","is","was","were","been",
  "i","you","we","they","me","my","your","our",
  "just","really","very","so","like","yeah","oh"
]);

function getWordStress(word) {
  const clean = word.toLowerCase().replace(/[^a-z']/g, "");

  // If CMU has the word, use real phoneme stress
  if (CMU_DICT && CMU_DICT[clean]) {
    const phones = CMU_DICT[clean][0];
    const stresses = phones
      .filter(p => /\d$/.test(p))
      .map(p => p.slice(-1) !== "0"); // true = stressed

    if (stresses.length) return stresses;
  }

  // FALLBACK: approximate stress from syllables
  const syls = countSyllables(clean);
  if (syls <= 0) return null;

  // Natural English pattern: strong-weak-strong-weak‚Ä¶
  const pattern = [];
  for (let i = 0; i < syls; i++) {
    pattern.push(i % 2 === 0);
  }
  return pattern;
}

function getLineStressPattern(line) {
  return line
    .split(/\s+/)
    .map(getWordStress)
    .filter(Boolean)
    .flat();
}

  
function contentDensity(line) {
  const words = line.toLowerCase().split(/\s+/).filter(Boolean);
  if (!words.length) return 0;

  const contentWords = words.filter(w => !FILLER_WORDS.has(w));
  return contentWords.length / words.length;
}


function paddingDensity(line) {
  const words = line.toLowerCase().split(/\s+/);
  if (!words.length) return 0;

  const fillerCount = words.filter(w => FILLER_WORDS.has(w)).length;
  return fillerCount / words.length;
}


function updateGutter() {
  gutter.textContent = editor.innerText
    .split("\n")
    .map(line =>
      line.split(/\s+/).filter(Boolean)
      .reduce((sum, w) => sum + countSyllables(w), 0)
    ).join("\n");
}
// === Restore saved lyrics ===
const savedLyrics = localStorage.getItem(LYRICS_KEY);
if (savedLyrics) {
  editor.innerHTML = savedLyrics;
  updateGutter();
}

/* ===============================
   REPETITION ALERT
   =============================== */

const repetitionAlert = document.getElementById("repetitionAlert");
const repToggle = document.getElementById("repToggle");

let repetitionEnabled = true;

repToggle.onclick = () => {
  repetitionEnabled = !repetitionEnabled;

  repetitionAlert.style.display = repetitionEnabled ? "block" : "none";
  repToggle.classList.toggle("active", repetitionEnabled);
  repToggle.textContent = repetitionEnabled
    ? "Repetition On"
    : "Repetition Off";
};

const STOP_WORDS = new Set([
  "the","and","a","to","of","in","on","it","is","that","for","with",
  "i","you","me","my","your","we","they","he","she","it's","im"
]);

function normalizeLyrics(text) {
  return text
    .toLowerCase()
    .replace(/[^\w\s']/g, "")
    .split(/\s+/)
    .filter(Boolean);
}

function findRepeatedWords(words, minCount = 3) {
  const counts = {};
  for (const w of words) {
    if (STOP_WORDS.has(w)) continue;
    counts[w] = (counts[w] || 0) + 1;
  }

  return Object.entries(counts)
    .filter(([, count]) => count >= minCount)
    .sort((a, b) => b[1] - a[1]);
}

function updateRepetitionAlert() {
  const words = normalizeLyrics(editor.innerText);
  const repeats = findRepeatedWords(words);

  if (!repeats.length) {
    repetitionAlert.style.display = "none";
    repetitionAlert.innerHTML = "";
    return;
  }

  repetitionAlert.style.display = "block";
  repetitionAlert.innerHTML =
    "‚ôªÔ∏è Repetition noticed: " +
    repeats
      .slice(0, 5)
      .map(([word, count]) => `"${word}" √ó${count}`)
      .join(" ¬∑ ");
}

titleInput.addEventListener("input", () => {
  localStorage.setItem(TITLE_KEY, titleInput.value);
});
editor.addEventListener("input", updateGutter);
editor.addEventListener("scroll", () => gutter.scrollTop = editor.scrollTop);
updateGutter();
editor.addEventListener("input", () => {
  localStorage.setItem(LYRICS_KEY, editor.innerHTML);
});

editor.addEventListener("input", updateRepetitionAlert);
/* === Fix Enter Key (Single Line Break) === */
editor.addEventListener("keydown", function(e) {
  if (e.key === "Enter") {
    e.preventDefault();
    const br = document.createElement("br");
    const selection = window.getSelection();
    const range = selection.getRangeAt(0);
    range.deleteContents();
    range.insertNode(br);
    const newRange = document.createRange();
    newRange.setStartAfter(br);
    newRange.collapse(true);
    selection.removeAllRanges();
    selection.addRange(newRange);
    updateGutter();
  }
});

/* === Font Controls === */
function getFontSize() {
  return parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--font-size"));
}

document.getElementById("fontUp").onclick = () => {
  const size = Math.min(getFontSize() + 1, 72);
  root.setProperty("--font-size", size + "px");
  save("fontSize", size + "px");
  updateGutter();
};

document.getElementById("fontDown").onclick = () => {
  const size = Math.max(getFontSize() - 1, 8);
  root.setProperty("--font-size", size + "px");
  save("fontSize", size + "px");
  updateGutter();
};

/* === Color Picker === */
document.getElementById("textColor").addEventListener("input", e => {
  root.setProperty("--text-color", e.target.value);
  save("textColor", e.target.value);
});

/* === Highlight Selected Text === */
document.getElementById("highlightBtn").onclick = () => {
  const color = document.getElementById("highlightColor").value;
  const sel = window.getSelection();
  if (!sel.rangeCount || sel.isCollapsed) return;

  const range = sel.getRangeAt(0);

  // Check if selection is already inside a highlight span
  let node = range.commonAncestorContainer;
  if (node.nodeType === 3) node = node.parentNode;

  const highlightSpan = node.closest("span");

  // üîÑ UNHIGHLIGHT
  if (highlightSpan && highlightSpan.style.backgroundColor) {
    const parent = highlightSpan.parentNode;

    while (highlightSpan.firstChild) {
      parent.insertBefore(highlightSpan.firstChild, highlightSpan);
    }

    parent.removeChild(highlightSpan);
    parent.normalize();
    return;
  }

  // ‚ú® APPLY HIGHLIGHT
  const span = document.createElement("span");
  span.style.backgroundColor = color;

  const contents = range.extractContents();
  span.appendChild(contents);
  range.insertNode(span);

  sel.removeAllRanges();
};

/* ===============================
   SAVE / OPEN / NEW
   =============================== */

// Helper: build file content (title + lyrics)
function getFileContent() {
  return (titleInput.value ? titleInput.value + "\n\n" : "") +
         editor.innerText;
}

// Helper: parse file content back into title + lyrics
function parseFileContent(text) {
  const lines = text.split("\n");

  if (lines[0]?.trim() && lines[1]?.trim() === "") {
    titleInput.value = lines.shift();
    lines.shift();
  } else {
    titleInput.value = "";
  }

  editor.innerText = lines.join("\n");
  updateGutter();

  // sync autosave
  localStorage.setItem(TITLE_KEY, titleInput.value);
  localStorage.setItem(LYRICS_KEY, editor.innerHTML);
}

// üîπ Dropbox load helper (GLOBAL ‚Äî NOT nested)
async function loadDropboxFile(url) {
  try {
    const res = await fetch(url);
    const text = await res.text();

    parseFileContent(text);

    alert("Loaded from Dropbox");
  } catch (err) {
    console.error("Dropbox load error:", err);
    alert("Failed to load file from Dropbox");
  }
}

// SAVE (auto filename from title)
document.getElementById("saveBtn").onclick = () => {
  const name =
    (titleInput.value && makeSafeFilename(titleInput.value)) || "lyrics";

  const blob = new Blob([getFileContent()], { type: "text/plain" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = name + ".txt";
  a.click();
};


// SAVE AS
document.getElementById("saveAsBtn").onclick = () => {
  const defaultName =
    (titleInput.value && makeSafeFilename(titleInput.value)) || "lyrics";

  const filename = prompt("Save as:", defaultName);
  if (!filename) return;

  const blob = new Blob([getFileContent()], { type: "text/plain" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename.endsWith(".txt")
    ? filename
    : filename + ".txt";
  a.click();
};

// OPEN
document.getElementById("openBtn").onclick = () => {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = ".txt";

  input.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;

    file.text().then(parseFileContent);
  };

  input.click();
};

// NEW
document.getElementById("newBtn").onclick = () => {
  if (!confirm("Start a new song? Unsaved changes will be lost.")) return;

  titleInput.value = "";
  editor.innerText = "";
  updateGutter();

  localStorage.removeItem(TITLE_KEY);
  localStorage.removeItem(LYRICS_KEY);
};

/* ===============================
   REFERENCE TABS
   =============================== */

function setTab(key) {
  document.querySelectorAll(".tab").forEach(tab => {
    tab.classList.toggle("active", tab.dataset.site === key);
  });

  hint.style.display = "none";

  if (key === "rhyme") {
    frame.src = "https://www.rhymezone.com/";
  }

  if (key === "exercises") {
    frame.src = "https://writingexercises.co.uk/";
  }


  if (key === "wiki") {
    frame.src = "https://en.wikipedia.org/wiki/Main_Page";
  }

}

document.querySelectorAll(".tab").forEach(tab => {
  tab.addEventListener("click", () => {
    setTab(tab.dataset.site);
  });
});

/* ===============================
   DOUBLE-CLICK ‚Üí RHYMEZONE
   =============================== */

editor.addEventListener("dblclick", () => {
  const word = window.getSelection().toString().trim();
  if (!word || !/^[a-zA-Z]+$/.test(word)) return;

  const url =
    `https://www.rhymezone.com/r/rhyme.cgi?Word=${encodeURIComponent(word)}&typeofrhyme=perfect`;

  setTab("rhyme");
  frame.src = url;
  hint.style.display = "block";
  hint.innerHTML =
    `üîç Searching <strong>${word}</strong> in RhymeZone.<br>
     If results don‚Äôt load,
     <a href="${url}" target="_blank">click here</a>.`;
});

/* ===============================
   METRONOME
   =============================== */

let metronomeInterval = null;
let beatCount = 0;

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
   async function ensureAudio() {
  if (audioCtx.state !== "running") {
    try { await audioCtx.resume(); } catch(e) {}
  }
}
const metronomeLight = document.getElementById("metronomeLight");
const bpmInput = document.getElementById("bpmInput");
const toggleBtn = document.getElementById("metronomeToggle");
const timeSignatureSelect = document.getElementById("timeSignature");

let beatsPerMeasure = parseInt(timeSignatureSelect.value);

// Update beats per measure when time signature changes
timeSignatureSelect.addEventListener("change", () => {
  beatsPerMeasure = parseInt(timeSignatureSelect.value);
  beatCount = 0;
});

// Play a single metronome tick
function playTick() {
  const isFirstBeat = beatCount % beatsPerMeasure === 0;

  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.type = "sine";
  osc.frequency.setValueAtTime(
    isFirstBeat ? 1500 : 1000,
    audioCtx.currentTime
  );

  gain.gain.setValueAtTime(0, audioCtx.currentTime);
  gain.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 0.01);
  gain.gain.exponentialRampToValueAtTime(
    0.001,
    audioCtx.currentTime + 0.1
  );

  osc.connect(gain);
  gain.connect(audioCtx.destination);

  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + 0.15);

  // Light flash
  metronomeLight.classList.remove("on", "first");
  void metronomeLight.offsetWidth; // restart animation
  metronomeLight.classList.add(isFirstBeat ? "first" : "on");

  setTimeout(() => {
    metronomeLight.classList.remove("on", "first");
  }, 100);
editor.classList.remove("beat-pulse", "first");
void editor.offsetWidth; // restart animation
editor.classList.add("beat-pulse");
if (isFirstBeat) editor.classList.add("first");
  beatCount++;
}

// Start metronome
function startMetronome(bpm) {
  const interval = 60000 / bpm;
  playTick();
  metronomeInterval = setInterval(playTick, interval);
}

// Stop metronome
function stopMetronome() {
  clearInterval(metronomeInterval);
  metronomeInterval = null;
  beatCount = 0;
}

// Toggle button
toggleBtn.addEventListener("click", async () => {
  const bpm = parseInt(bpmInput.value);

  if (metronomeInterval) {
    stopMetronome();
    toggleBtn.textContent = "Start";
  } else if (!isNaN(bpm) && bpm > 0) {
    await ensureAudio();
    startMetronome(bpm);
    toggleBtn.textContent = "Stop";
  }
});
    

/* ===============================
   REFERENCE SIZE SLIDER
   =============================== */

const refPanel = document.querySelector(".reference-panel");
const refSlider = document.getElementById("refSizeSlider");

refSlider.addEventListener("input", () => {
  refPanel.style.height = refSlider.value + "px";

});


/* ===============================
   REFERENCE FULLSCREEN
   =============================== */

const fsBtn = document.getElementById("refFullscreenBtn");

fsBtn.addEventListener("click", async () => {
  if (!document.fullscreenElement) {
    await refPanel.requestFullscreen();
  } else {
    await document.exitFullscreen();
  }
});

document.addEventListener("fullscreenchange", () => {
  fsBtn.textContent = document.fullscreenElement
    ? "Exit Fullscreen"
    : "Reference Fullscreen";
});

/* ===============================
   PERFORMANCE MODE TOGGLE
   =============================== */

const performanceBtn = document.getElementById("performanceToggle");

performanceBtn.onclick = () => {
  document.body.classList.toggle("performance-mode");

  performanceBtn.textContent =
    document.body.classList.contains("performance-mode")
      ? "Exit Performance"
      : "Performance";
};


document.addEventListener("DOMContentLoaded", () => {
  const mobileControls = document.getElementById("mobileControls");
  const mobileToolbar = document.getElementById("mobileToolbar");

  const metroPanel = document.querySelector(".metronome-panel");
  const toolbar = document.querySelector(".toolbar");

  if (mobileControls && metroPanel) {
    mobileControls.addEventListener("click", () => {
      metroPanel.classList.toggle("open");
    });
  }

  if (mobileToolbar && toolbar) {
    mobileToolbar.addEventListener("click", () => {
      toolbar.classList.toggle("open");
    });
  }
});







/* ===============================
   RHYTHM LIGHT + DEBUG
   =============================== */

function updateRhythmLight() {
  const selection = window.getSelection();

  if (!selection || selection.isCollapsed) {
    turnRhythmOff();
    return;
  }

  const range = selection.getRangeAt(0);
  if (!editor.contains(range.commonAncestorContainer)) {
    turnRhythmOff();
    return;
  }

  const lines = selection.toString()
    .split("\n")
    .map(l => l.trim())
    .filter(Boolean);

  if (lines.length < 2) {
    turnRhythmOff();
    return;
  }

  // Only compare the first two selected lines
  const aLine = lines[0];
  const bLine = lines[1];

  // === SYLLABLE CHECK ===
  const aSyl = aLine.split(/\s+/).filter(Boolean).reduce((s, w) => s + countSyllables(w), 0);
  const bSyl = bLine.split(/\s+/).filter(Boolean).reduce((s, w) => s + countSyllables(w), 0);
  const variance = Math.abs(aSyl - bSyl);

  // === STRESS CHECK ===
  const stressA = getLineStressPattern(aLine);
  const stressB = getLineStressPattern(bLine);

  let stressPass = true;
  let stressScore = 1;

  const len = Math.min(stressA.length, stressB.length);

  if (len >= 3) {
    let matches = 0;
    let strong = 0;

    for (let i = 0; i < len; i++) {
      if (stressA[i]) strong++;
      if (stressA[i] === stressB[i] && stressA[i]) matches++;
    }

    const matchRatio = matches / len;
    const strongRatio = strong / len;

    // "Contour": punish chant (all stressed or none stressed)
    const contour = 1 - Math.abs(0.5 - strongRatio) * 2; // 0..1

    stressScore = 0.7 * matchRatio + 0.3 * contour;
    stressPass = stressScore >= STRESS_STRICTNESS;
  } else {
    // Not enough stress data ‚Üí don't judge
    stressPass = true;
    stressScore = 1;
  }

  // === PADDING CHECK (both lines must be padded to fail)
  const paddingA = paddingDensity(aLine);
  const paddingB = paddingDensity(bLine);
  const padded = paddingA > PAD_THRESHOLD && paddingB > PAD_THRESHOLD;

  // === DENSITY CHECK (both lines must be dense to fail)
  const densityA = contentDensity(aLine);
  const densityB = contentDensity(bLine);
  const dense = densityA > DENSITY_THRESHOLD && densityB > DENSITY_THRESHOLD;

  const varianceFail = variance > VARIANCE_THRESHOLD;

  const pass =
    !varianceFail &&
    stressPass &&
    !padded &&
    !dense;

  // === UI UPDATE ===
  if (pass) {
    rhythmLight.style.backgroundColor = "#3fa";
    rhythmLight.style.boxShadow = "0 0 8px #3fa";
  } else {
    rhythmLight.style.backgroundColor = "#f44";
    rhythmLight.style.boxShadow = "0 0 10px #f44";
  }

  // === DEBUG BOX ===
  if (rhythmDebug) {
    if (pass) {
      rhythmDebug.innerHTML =
        `‚úì Rhythm OK<br><span style="opacity:.75">Syl ${aSyl}/${bSyl} ‚Ä¢ Stress ${stressScore.toFixed(2)}</span>`;
    } else {
      const reasons = [];
      if (varianceFail) reasons.push(`Syllables uneven (${aSyl} vs ${bSyl})`);
      if (!stressPass) reasons.push(`Stress misaligned (${stressScore.toFixed(2)} < ${STRESS_STRICTNESS})`);
      if (padded) reasons.push("Too many filler words");
      if (dense) reasons.push("Too many content words");
      rhythmDebug.innerHTML = reasons.join("<br>");
    }
  }
}

function turnRhythmOff() {
  rhythmLight.style.backgroundColor = "#444";
  rhythmLight.style.boxShadow = "0 0 4px #000";
  if (rhythmDebug) rhythmDebug.innerHTML = "";
}

document.addEventListener("selectionchange", updateRhythmLight);
editor.addEventListener("input", updateRhythmLight);



document.getElementById("saveToDropbox").onclick = async () => {
  const token = localStorage.getItem("dropbox_access_token");

  if (!token) {
    alert("Please connect Dropbox first.");
    return;
  }

  const filename =
    makeSafeFilename(titleInput.value || "Untitled") + ".txt";

  const content = getFileContent();

  try {
    const res = await fetch("/.netlify/functions/dropbox-save", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        token,
        filename,
        content
      })
    });

    const data = await res.json();

    if (!res.ok) {
      throw new Error(data.error || "Save failed");
    }

    alert("Saved to Dropbox ‚úì");
  } catch (err) {
    console.error(err);
    alert("Dropbox save failed");
  }
};




document.getElementById("loadFromDropbox").addEventListener("click", () => {
  Dropbox.choose({
    linkType: "direct",
    multiselect: false,
    extensions: [".txt"],
    success: files => {
      const file = files[0];
      loadDropboxFile(file.link);
    }
  });
});


// ===============================
// AI DRAWER
// ===============================

function createAIDrawer() {
  if (document.getElementById("aiDrawer")) return;

  const div = document.createElement("div");
  div.id = "aiDrawer";

  div.innerHTML = `
    <div class="ai-header">
      <span>Lyric AI</span>
      <button id="aiClose">‚úï</button>
    </div>
    <div id="aiMessages"></div>
    <div class="ai-input">
      <input id="aiPrompt" placeholder="Ask about your lyrics‚Ä¶" />
      <button id="aiSend">Send</button>
    </div>
  `;

  document.getElementById("aiRoot").appendChild(div);

  document.getElementById("aiClose").onclick = destroyAIDrawer;
  document.getElementById("aiSend").onclick = sendToAI;
}

function destroyAIDrawer() {
  const el = document.getElementById("aiDrawer");
  if (el) el.remove();
}

document.getElementById("aiToggle").onclick = () => {
  if (document.getElementById("aiDrawer")) {
    destroyAIDrawer();
  } else {
    createAIDrawer();
  }
};

async function sendToAI() {
  const input = document.getElementById("aiPrompt");
  const text = input.value.trim();
  if (!text) return;

  const box = document.getElementById("aiMessages");
  box.innerHTML += `<div>üßë ${text}</div>`;
  input.value = "";

  const res = await fetch("/.netlify/functions/chat", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ message: text })
  });

  const data = await res.json();

  if (data.error) {
    box.innerHTML += `<div style="color:#f66">‚ùå ${data.error}</div>`;
  } else {
    box.innerHTML += `<div>ü§ñ ${data.reply}</div>`;
  }

  box.scrollTop = box.scrollHeight;
}


const rhymeToggle = document.getElementById("rhymeToggle");

rhymeToggle.onclick = () => {
  rhymeEnabled = !rhymeEnabled;

  rhymeToggle.classList.toggle("active", rhymeEnabled);
  rhymeToggle.textContent = rhymeEnabled ? "Hide Rhyme" : "Show Rhyme";

  if (rhymeEnabled) {
    applyRhymeColors();
  } else {
    removeRhymeColors();
  }
};



// Start OAuth
document.getElementById("connectDropbox").onclick = () => {
 const redirectUri =
  "https://tranquillyrics.netlify.app/";

  const authUrl =
    "https://www.dropbox.com/oauth2/authorize" +
    "?response_type=token" +
    "&client_id=" + DROPBOX_APP_KEY +
    "&redirect_uri=" + encodeURIComponent(redirectUri);

  window.location.href = authUrl;
};

(function handleDropboxAuth() {
  if (!window.location.hash) return;

  const params = new URLSearchParams(
    window.location.hash.substring(1)
  );

  const token = params.get("access_token");

  if (token) {
    localStorage.setItem(DROPBOX_TOKEN_KEY, token);

    // Clean the URL
    window.history.replaceState(
      {},
      document.title,
      window.location.pathname
    );

    alert("Dropbox connected successfully!");
  }
})();

function isDropboxConnected() {
  return !!localStorage.getItem(DROPBOX_TOKEN_KEY);
}

const player = document.getElementById("radio-player");
const prevBtn = document.getElementById("prev-radio");
const nextBtn = document.getElementById("next-radio");
const radioToggleBtn = document.getElementById("toggle-radio");

let currentStation = 0;
let isPlaying = false;


function playStation(index) {
  player.pause();
  player.src = "";
  player.src = stations[index].url;

  player.play().then(() => {
    isPlaying = true;
    radioToggleBtn.textContent = "‚è∏";
  }).catch(err => {
    console.error("Radio play failed:", err);
  });
}
radioToggleBtn.onclick = () => {
  if (isPlaying) {
    player.pause();
    isPlaying = false;
    radioToggleBtn.textContent = "‚ñ∂";
  } else {
    playStation(currentStation);
  }
};

prevBtn.onclick = () => {
  currentStation =
    (currentStation - 1 + stations.length) % stations.length;
  playStation(currentStation);
};

nextBtn.onclick = () => {
  currentStation =
    (currentStation + 1) % stations.length;
  playStation(currentStation);
};
  
</script>
<div id="aiRoot"></div>
<script
  src="https://www.dropbox.com/static/api/2/dropins.js"
  id="dropboxjs"
  data-app-key="aqspa246xk6m1mt">
</script>
<button id="mobileControls" class="mobile-fab">Controls</button>
<button id="mobileToolbar" class="mobile-fab">Tools</button>



</body>
</html>
